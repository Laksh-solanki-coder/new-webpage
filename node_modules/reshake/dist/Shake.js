var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx } from "react/jsx-runtime";
import { useMemo } from 'react';
import styled, { keyframes } from 'styled-components';
var toString = function (obj) {
    return Object.keys(obj).reduce(function (acc, next) {
        return "".concat(acc, "\n\t\t\t").concat(next, " {\n\t\t\t\ttransform: ").concat(obj[next].transform, "\n\t\t\t}");
    }, '');
};
var ShakeComp = styled.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  animation-name: ", ";\n  animation-duration: ", "ms;\n  animation-iteration-count: ", ";\n  display: 'inline-block';\n  transform-origin: ", ";\n\n  &", " {\n    animation-name: ", ";\n    animation-play-state: ", ";\n    animation: ", ";\n  }\n\n  animation-play-state: ", ";\n"], ["\n  animation-name: ", ";\n  animation-duration: ", "ms;\n  animation-iteration-count: ", ";\n  display: 'inline-block';\n  transform-origin: ", ";\n\n  &", " {\n    animation-name: ", ";\n    animation-play-state: ", ";\n    animation: ", ";\n  }\n\n  animation-play-state: ", ";\n"])), function (p) { return p.shouldShakeDefault && p.shakeKeyframes; }, function (p) { return p.dur; }, function (p) { return p.q; }, function (p) { return p.orig; }, function (p) { return p.trigger; }, function (p) { return p.shouldShakeWhenTriggered && p.shakeKeyframes; }, function (p) {
    return p.freez && (!p.fixed ? 'running' : 'paused');
}, function (p) { return p.fixed && p.fixedStop && 'initial'; }, function (p) {
    return p.active ? (p.freez && !p.fixed ? 'paused' : 'running') : 'paused';
});
var random = function (max, min) {
    if (min === void 0) { min = 0; }
    return Math.random() * (max - min) - max / 2;
};
var doKeyframes = function (int, max, h, v, r) {
    var init = 'translate(0,0) rotate(0)';
    // el objecto que iremos llenando
    var kf = {
        '0%': {
            transform: init,
        },
    };
    // loop con intervalos basados en `int`
    for (var st = int; st <= max; st += int) {
        // Numeros aleatorios en cada keyframe
        var x = random(h);
        var y = random(v);
        var rot = random(r);
        kf["".concat(st, "%")] = {
            transform: "translate(".concat(x, "px, ").concat(y, "px) rotate(").concat(rot, "deg)"),
        };
    }
    // Init de las transformaciones en 0% y 100%
    kf["".concat(Math.min(max, 100), "%")] = {
        transform: init,
    };
    return toString(kf);
};
var Shake = function (_a) {
    var _b = _a.h, h = _b === void 0 ? 5 : _b, _c = _a.v, v = _c === void 0 ? 5 : _c, _d = _a.r, r = _d === void 0 ? 3 : _d, _e = _a.dur, dur = _e === void 0 ? 300 : _e, _f = _a.q, q = _f === void 0 ? 'infinite' : _f, _g = _a.tf, tf = _g === void 0 ? 'ease-in-out' : _g, _h = _a.int, int = _h === void 0 ? 10 : _h, _j = _a.max, max = _j === void 0 ? 100 : _j, _k = _a.orig, orig = _k === void 0 ? 'center center' : _k, _l = _a.fixed, fixed = _l === void 0 ? false : _l, _m = _a.freez, freez = _m === void 0 ? false : _m, _o = _a.active, active = _o === void 0 ? true : _o, _p = _a.trigger, trigger = _p === void 0 ? ':hover' : _p, _q = _a.fixedStop, fixedStop = _q === void 0 ? false : _q, _r = _a.elem, elem = _r === void 0 ? 'div' : _r, props = __rest(_a, ["h", "v", "r", "dur", "q", "tf", "int", "max", "orig", "fixed", "freez", "active", "trigger", "fixedStop", "elem"]);
    // Creamos los @keyframes
    var shakeKeyframes = useMemo(function () { return keyframes(templateObject_2 || (templateObject_2 = __makeTemplateObject(["", ""], ["", ""])), doKeyframes(int, max, h, v, r)); }, [int, max, h, v, r]);
    var shouldShakeDefault = fixed || (!fixed && freez);
    var shouldShakeWhenTriggered = !fixed && !freez;
    return (_jsx(ShakeComp, __assign({ as: elem, dur: dur, orig: orig, q: q, freez: freez, fixed: fixed, fixedStop: fixedStop, active: active, trigger: trigger, shakeKeyframes: shakeKeyframes, shouldShakeDefault: shouldShakeDefault, shouldShakeWhenTriggered: shouldShakeWhenTriggered }, props, { children: props.children })));
};
export default Shake;
var templateObject_1, templateObject_2;
